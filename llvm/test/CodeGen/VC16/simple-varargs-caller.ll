; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv32 -verify-machineinstrs -debug < %s \
; RUN:   | FileCheck -check-prefix=VC16I %s

declare void @llvm.va_start(i8*)
declare void @llvm.va_end(i8*)

; Function Attrs: nounwind optsize
define dso_local void @f(i16 %c, ...) {
; VC16I-LABEL: f:
; VC16I:       # %bb.0: # %entry
; VC16I-NEXT:    addi sp, sp, -48
; VC16I-NEXT:    .cfi_def_cfa_offset 48
; VC16I-NEXT:    sw a7, 44(sp)
; VC16I-NEXT:    sw a6, 40(sp)
; VC16I-NEXT:    sw a5, 36(sp)
; VC16I-NEXT:    sw a4, 32(sp)
; VC16I-NEXT:    sw a3, 28(sp)
; VC16I-NEXT:    sw a2, 24(sp)
; VC16I-NEXT:    sw a1, 20(sp)
; VC16I-NEXT:    addi a1, sp, 20
; VC16I-NEXT:    sw a1, 12(sp)
; VC16I-NEXT:    sh a0, 2(zero)
; VC16I-NEXT:    lw a0, 12(sp)
; VC16I-NEXT:    addi a0, a0, 1
; VC16I-NEXT:    andi a0, a0, -2
; VC16I-NEXT:    addi a1, a0, 4
; VC16I-NEXT:    sw a1, 12(sp)
; VC16I-NEXT:    lw a0, 0(a0)
; VC16I-NEXT:    sh a0, 2(zero)
; VC16I-NEXT:    addi sp, sp, 48
; VC16I-NEXT:    ret
entry:
  %args = alloca i8*, align 2
  %0 = bitcast i8** %args to i8*
  call void @llvm.va_start(i8* nonnull %0)
  store volatile i16 %c, i16* inttoptr (i16 2 to i16*), align 2
  %1 = va_arg i8** %args, i16
  store volatile i16 %1, i16* inttoptr (i16 2 to i16*), align 2
  call void @llvm.va_end(i8* nonnull %0)
  ret void
}

; Function Attrs: noreturn nounwind optsize
define dso_local void @_start() {
; VC16I-LABEL: _start:
; VC16I:       # %bb.0: # %entry
; VC16I-NEXT:    addi sp, sp, -16
; VC16I-NEXT:    .cfi_def_cfa_offset 16
; VC16I-NEXT:    sw ra, 12(sp)
; VC16I-NEXT:    .cfi_offset ra, -4
; VC16I-NEXT:    addi a0, zero, 3
; VC16I-NEXT:    addi a1, zero, 1
; VC16I-NEXT:    call f
; VC16I-NEXT:  .LBB1_1: # %while.body
; VC16I-NEXT:    # =>This Inner Loop Header: Depth=1
; VC16I-NEXT:    j .LBB1_1
entry:
  tail call void (i16, ...) @f(i16 3, i16 1)
  br label %while.body

while.body:                                       ; preds = %entry, %while.body
  br label %while.body
}


; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=vc16 -verify-machineinstrs < %s \
; RUN:   | FileCheck %s -check-prefix=VC16I

; Register-immediate instructions

define i16 @ori(i16 %a) nounwind {
; VC16I-LABEL: ori:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    ori a0, 1
; VC16I-NEXT:    ret
  %1 = or i16 %a, 1
  ret i16 %1
}

define i16 @addi(i16 %a) nounwind {
; VC16I-LABEL: addi:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    lea a0, a0, 1
; VC16I-NEXT:    ret
  %1 = add i16 %a, 1
  ret i16 %1
}

define i16 @slli(i16 %a) nounwind {
; VC16I-LABEL: slli:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    slli a0, 1
; VC16I-NEXT:    ret
  %1 = shl i16 %a, 1
  ret i16 %1
}

define i16 @srli(i16 %a) nounwind {
; VC16I-LABEL: srli:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    srli a0, 1
; VC16I-NEXT:    ret
  %1 = lshr i16 %a, 1
  ret i16 %1
}

define i16 @srai(i16 %a) nounwind {
; VC16I-LABEL: srai:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    srai a0, 1
; VC16I-NEXT:    ret
  %1 = ashr i16 %a, 1
  ret i16 %1
}


define i16 @add(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: add:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    add a0, a1
; VC16I-NEXT:    ret
  %1 = add i16 %a, %b
  ret i16 %1
}

define i16 @sll(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: sll:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    sll a0, a1
; VC16I-NEXT:    ret
  %1 = shl i16 %a, %b
  ret i16 %1
}

define i16 @sub(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: sub:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    sub a0, a1
; VC16I-NEXT:    ret
  %1 = sub i16 %a, %b
  ret i16 %1
}

define i16 @srl(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: srl:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    srl a0, a1
; VC16I-NEXT:    ret
  %1 = lshr i16 %a, %b
  ret i16 %1
}

define i16 @and(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: and:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    and a0, a1
; VC16I-NEXT:    ret
  %1 = and i16 %a, %b
  ret i16 %1
}

define i16 @xor(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: xor:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    xor a0, a1
; VC16I-NEXT:    ret
  %1 = xor i16 %a, %b
  ret i16 %1
}


define i16 @or(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: or:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    or a0, a1
; VC16I-NEXT:    ret
  %1 = or i16 %a, %b
  ret i16 %1
}

define i16 @sra(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: sra:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    sra a0, a1
; VC16I-NEXT:    ret
  %1 = ashr i16 %a, %b
  ret i16 %1
}

define i16 @neg(i16 %a) nounwind {
; VC16I-LABEL: neg:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    neg a0, a0
; VC16I-NEXT:    ret
  %1 = sub i16 0, %a
  ret i16 %1
}

define i16 @not(i16 %a) nounwind {
; VC16I-LABEL: not:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    not a0, a0
; VC16I-NEXT:    ret
  %1 = xor i16 %a, -1
  ret i16 %1
}

; TODO(cristicbz): Test carry.
; TODO(cristicbz): Test all other ops.

define i16 @mul(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: mul:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    mul a0, a1
; VC16I-NEXT:    ret
  %1 = mul i16 %a, %b
  ret i16 %1
}

define i32 @mul32u(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: mul32u:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    mv a2, a0
; VC16I-NEXT:    mul a2, a1
; VC16I-NEXT:    mlhu a1, a0
; VC16I-NEXT:    mv a0, a2
; VC16I-NEXT:    ret
  %1 = zext i16 %a to i32
  %2 = zext i16 %b to i32
  %3 = mul i32 %1, %2
  ret i32 %3
}

define i32 @mul32s(i16 %a, i16 %b) nounwind {
; VC16I-LABEL: mul32s:
; VC16I:       ; %bb.0:
; VC16I-NEXT:    mv a2, a0
; VC16I-NEXT:    mul a2, a1
; VC16I-NEXT:    mlhs a1, a0
; VC16I-NEXT:    mv a0, a2
; VC16I-NEXT:    ret
  %1 = sext i16 %a to i32
  %2 = sext i16 %b to i32
  %3 = mul i32 %1, %2
  ret i32 %3
}
